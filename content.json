{"meta":{"title":"Nekilc","subtitle":"","description":"代码给你，PPT给我。","author":"Nekilc","url":"http://www.nekilc.com","root":"/"},"pages":[{"title":"关于","date":"2020-07-17T07:44:00.000Z","updated":"2020-08-02T13:03:28.710Z","comments":false,"path":"about/index.html","permalink":"http://www.nekilc.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-07-17T07:42:49.000Z","updated":"2020-08-02T11:16:10.921Z","comments":true,"path":"categories/index.html","permalink":"http://www.nekilc.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-03T11:29:04.000Z","updated":"2020-08-03T11:30:09.585Z","comments":true,"path":"links/index.html","permalink":"http://www.nekilc.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-17T07:42:32.000Z","updated":"2020-08-02T13:33:02.121Z","comments":true,"path":"tags/index.html","permalink":"http://www.nekilc.com/tags/index.html","excerpt":"","text":""},{"title":"仓库","date":"2020-08-02T10:42:13.000Z","updated":"2020-08-02T11:30:23.330Z","comments":true,"path":"repository/index.html","permalink":"http://www.nekilc.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue打包优化","slug":"运维/Vue打包优化","date":"2020-10-09T15:06:34.436Z","updated":"2020-10-10T00:42:10.596Z","comments":true,"path":"M4C3K9.html","link":"","permalink":"http://www.nekilc.com/M4C3K9.html","excerpt":"","text":"该项目由Vue脚手架生成。 文件 vue.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const cdn = &#123; css: [ 'https://unpkg.com/element-ui/lib/theme-chalk/index.css', ], js: [ 'https://unpkg.com/vue@2.6.12/dist/vue.min.js', 'https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js', 'https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js', 'https://cdn.bootcss.com/axios/0.18.0/axios.min.js', 'https://cdn.bootcss.com/echarts/4.1.0/echarts.min.js', 'https://unpkg.com/element-ui/lib/index.js', ]&#125;// eslint-disable-next-line @typescript-eslint/no-var-requires// 使用 webpack gzip压缩插件const CompressionPlugin = require('compression-webpack-plugin')module.exports = &#123; lintOnSave: false, chainWebpack: config =&gt; &#123; //关闭预加载，该功能会预测你下面要做的事情，然后提前加载资源 config.plugins.delete('prefetch') // 向 html 文件中注入js、css的cdn config.plugin('html') .tap(args =&gt; &#123; args[0].cdn = cdn; return args; &#125;); &#125;, configureWebpack: (config) =&gt; &#123; config.mode = 'production' return &#123; // 引入插件 plugins: [new CompressionPlugin(&#123; test: /\\.js$|\\.html$|\\.css/, //匹配文件名 threshold: 10240, //对超过 10k 的数据进行压缩 deleteOriginalAssets: false //是否删除原文件 &#125;)], resolve: &#123; alias: &#123; syyles: '@assets/styles' &#125; &#125;, // 声明以下模块为外部引入 // key : value，参照每个资源包导入的地方 // key 为外部模块名称 // value 为内部全局引用名称 externals: &#123; 'vue': 'Vue', 'vuex': 'Vuex', 'vue-router': 'VueRouter', 'axios': 'axios', \"echarts\": \"echarts\", \"element-ui\": \"ELEMENT\"// 这里我暂时也不清楚为什么这么引入 &#125;, &#125; &#125;,&#125; 文件 public/index.html 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt; &lt;!-- 使用CDN的CSS文件 注入 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.css) &#123; %&gt; &lt;link href=\"&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;\" rel=\"stylesheet\"&gt; &lt;% &#125; %&gt; &lt;!-- 使用CDN的JS文件 注入 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp; htmlWebpackPlugin.options.cdn.js) &#123; %&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;\"&gt;&lt;/script&gt; &lt;% &#125; %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt; &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;&lt;/noscript&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;style&gt; body&#123; margin: 0 !important; &#125; .fa-icon &#123; width: auto ; height: 1.2em ; max-width: 100%; max-height: 100%; margin-right: 0.5em; &#125;&lt;/style&gt;&lt;/html&gt; 运行 npm run build 打包，结果： 12345678910111213141516171819File Size Gzipped dist&#x2F;js&#x2F;chunk-vendors.5ff82869.js 1185.98 KiB 368.74 KiB dist&#x2F;js&#x2F;chunk-0ab245a4.96b932f4.js 28.83 KiB 7.20 KiB dist&#x2F;js&#x2F;app.78e9f699.js 15.87 KiB 4.02 KiB dist&#x2F;js&#x2F;chunk-b6c1adf0.cdf11fc8.js 14.96 KiB 4.83 KiB dist&#x2F;js&#x2F;chunk-bcab546a.102e35ae.js 7.77 KiB 2.95 KiB dist&#x2F;js&#x2F;chunk-4486737d.63562d86.js 5.56 KiB 1.99 KiB dist&#x2F;js&#x2F;about.32c62c99.js 4.24 KiB 1.70 KiB dist&#x2F;js&#x2F;chunk-092b5b6d.e0847ea0.js 3.18 KiB 1.23 KiB dist&#x2F;js&#x2F;chunk-2d21e30b.5f9f08f4.js 0.36 KiB 0.28 KiB dist&#x2F;css&#x2F;chunk-vendors.96889e61.css 205.25 KiB 32.96 KiB dist&#x2F;css&#x2F;chunk-0ab245a4.2a37ff65.css 1.60 KiB 0.47 KiB dist&#x2F;css&#x2F;chunk-4486737d.202f9498.css 0.89 KiB 0.35 KiB dist&#x2F;css&#x2F;chunk-b6c1adf0.51307730.css 0.49 KiB 0.23 KiB dist&#x2F;css&#x2F;chunk-bcab546a.0f4b8451.css 0.44 KiB 0.22 KiB dist&#x2F;css&#x2F;app.0a82b120.css 0.39 KiB 0.24 KiB dist&#x2F;css&#x2F;about.4c5e0428.css 0.14 KiB 0.11 KiB dist&#x2F;css&#x2F;chunk-092b5b6d.18d1a564.css 0.14 KiB 0.12 KiB 可以发现无论是原件体积或是gzip压缩后的文件体积都减少了很多。而且你可以看见目录下还多了gz结尾的文件，这就是gzip压缩后的文件，接下来就可以使用nginx静态gzip部署了。","categories":[{"name":"运维","slug":"运维","permalink":"http://www.nekilc.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.nekilc.com/tags/Vue/"},{"name":"Java","slug":"Java","permalink":"http://www.nekilc.com/tags/Java/"}]},{"title":"6种负载均衡算法Golang实现","slug":"杂文/6种负载均衡算法Golang实现","date":"2020-09-22T16:08:36.254Z","updated":"2020-10-10T00:46:33.229Z","comments":true,"path":"3BV5S52.html","link":"","permalink":"http://www.nekilc.com/3BV5S52.html","excerpt":"","text":"六种负载均衡算法 1. 轮询法 将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。 12345678910111213141516171819202122232425262728293031type RoundRobinLoadBalancer struct &#123; currentIndex int hostList []*HostUrl&#125;// Format: 192.168.1.1:9999func (r *RoundRobinLoadBalancer) AddHost(host *HostUrl, hosts ...*HostUrl) error &#123; r.hostList = append(r.hostList, host) for _, h := range hosts &#123; r.hostList = append(r.hostList, h) &#125; return nil&#125;func (r *RoundRobinLoadBalancer) GetHost(key string) (*HostUrl, error) &#123; length := len(r.hostList) if length == 0 &#123; return nil, Error_NoAvailableHost &#125; if r.currentIndex &gt;= length &#123; r.currentIndex = 0 &#125; current := r.currentIndex r.currentIndex = (r.currentIndex + 1) % length return r.hostList[current], nil&#125; 2. 随机法 通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。 1234567891011121314151617181920212223type RandomBalance struct &#123; index uint hostList []*HostUrl conf BalanceConf&#125;// Format: 192.168.1.1:9999func (r *RandomBalance) AddHost(host *HostUrl, hosts ...*HostUrl) error &#123; r.hostList = append(r.hostList, host) for _, h := range hosts &#123; r.hostList = append(r.hostList, h) &#125; return nil&#125;func (r *RandomBalance) GetHost(key string) (*HostUrl, error) &#123; length := len(r.hostList) if length == 0 &#123; return nil, Error_NoAvailableHost &#125; index := rand.Intn(length) return r.hostList[index], nil&#125; 3. 源地址哈希法 源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。 1234567891011121314151617181920212223type ConsistentHashLoadBalancer struct &#123; hostList []*HostUrl&#125;// Format: 192.168.1.1:9999func (r *ConsistentHashLoadBalancer) AddHost(host *HostUrl, hosts ...*HostUrl) error &#123; r.hostList = append(r.hostList, host) for _, h := range hosts &#123; r.hostList = append(r.hostList, h) &#125; return nil&#125;func (c *ConsistentHashLoadBalancer) GetHost(key string) (*HostUrl, error) &#123; length := len(c.hostList) if length == 0 &#123; return nil, Error_NoAvailableHost &#125; hash := crc32.ChecksumIEEE([]byte(key)) hashAddr := c.hostList[hash%uint32(length)] return hashAddr, nil&#125; 4. 加权轮询法 不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354type WeightRobinLoadBalance struct &#123; hostList []*WeightNode currentWeight int&#125;type WeightNode struct &#123; Weight int CurrentWeight int Addr *url.URL&#125;// Format: 192.168.1.1:9999 60func (r *WeightRobinLoadBalance) AddHost(host *HostUrl, hosts ...*HostUrl) error &#123; node := &amp;WeightNode&#123; Weight: host.Weight, CurrentWeight: 0, Addr: host.URL, &#125; r.hostList = append(r.hostList, node) if len(hosts) != 0 &#123; for _, h := range hosts &#123; node := &amp;WeightNode&#123; Weight: h.Weight, CurrentWeight: 0, Addr: h.URL, &#125; r.hostList = append(r.hostList, node) &#125; &#125; return nil&#125;func (w *WeightRobinLoadBalance) GetHost(key string) (*HostUrl, error) &#123; total := 0 var best *WeightNode for _, node := range w.hostList &#123; total += node.Weight node.CurrentWeight += node.Weight if best == nil || node.CurrentWeight &gt; best.CurrentWeight &#123; best = node &#125; &#125; if best != nil &#123; best.CurrentWeight -= total return &amp;HostUrl&#123; URL: best.Addr, Weight: best.Weight, &#125;, nil &#125; return nil, Error_NoAvailableHost&#125; 5. 加权随机法 与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。 6. 最小连接数法 最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。","categories":[{"name":"杂文","slug":"杂文","permalink":"http://www.nekilc.com/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://www.nekilc.com/tags/Golang/"}]},{"title":"Docker部署Mysql数据库","slug":"运维/Docker部署Mysql数据库","date":"2020-09-22T16:07:57.186Z","updated":"2020-09-23T09:34:52.067Z","comments":true,"path":"22X88J.html","link":"","permalink":"http://www.nekilc.com/22X88J.html","excerpt":"","text":"Docker部署Mysql数据库 1. 简单使用 12docker pull mysql:5.7.28docker run --name mysql -e MYSQL_ROOT_PASSWORD=12345 -p 3306:3306 -d mysql:5.7.28 2. 指定本机配置文件 1-v /my/custom:/etc/mysql/conf.d 3. 持久化数据/指定本机数据储存 1-v /my/own/datadir:/var/lib/mysql 4. 指定字符集 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci `","categories":[{"name":"运维","slug":"运维","permalink":"http://www.nekilc.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.nekilc.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Docker-Redis集群搭建","slug":"运维/Docker-Redis集群搭建","date":"2020-09-21T05:39:12.389Z","updated":"2020-09-21T10:30:55.729Z","comments":true,"path":"25EVPV8.html","link":"","permalink":"http://www.nekilc.com/25EVPV8.html","excerpt":"","text":"新建docker网桥 docker network create --driver bridge --subnet=172.19.0.0/16 redis-bridge 新建脚本文件 123456789101112port $&#123;PORT&#125;protected-mode nobind 0.0.0.0requirepass 123456789masterauth 123456789cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.19.0.$&#123;TEMP&#125;cluster-announce-port $&#123;PORT&#125;cluster-announce-bus-port 1$&#123;PORT&#125;appendonly yes 通过脚本文件生成各节点配置文件 1234567for port in `seq 7010 7015`; do \\base=7008 \\&amp;&amp; ip=$[port-base] \\&amp;&amp; mkdir -p ./$&#123;port&#125;/conf \\&amp;&amp; PORT=$&#123;port&#125; TEMP=$&#123;ip&#125; envsubst &lt; ./template.tmpl &gt; ./$&#123;port&#125;/conf/redis.conf \\&amp;&amp; mkdir -p ./$&#123;port&#125;/data; \\done 启动所有节点。 123456789for port in `seq 7010 7015`; do \\base=7008myips=$[port-base]docker run -d -it -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; \\--privileged=true -v /root/data/redis/$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf \\--privileged=true -v /root/data/redis/$&#123;port&#125;/data:/data \\--restart always --name redis-$&#123;port&#125; --net redis-bridge --ip 172.19.0.$&#123;myips&#125; \\--sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf; \\done 创建集群。 1docker exec -it redis-7010 redis-cli --cluster create 172.19.0.2:7010 172.19.0.3:7011 172.19.0.4:7012 172.19.0.5:7013 172.19.0.6:7014 172.19.0.7:7015 --cluster-replicas 1 -a 123456789 验证集群","categories":[{"name":"运维","slug":"运维","permalink":"http://www.nekilc.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[]},{"title":"Sync包Once源码解析","slug":"Golang/Sync包Once源码解析","date":"2020-09-18T13:36:10.937Z","updated":"2020-09-19T04:37:39.190Z","comments":true,"path":"1ZDB32G.html","link":"","permalink":"http://www.nekilc.com/1ZDB32G.html","excerpt":"","text":"根据源码中的描述，可以总结出：一个Once只能被使用一次 12345678910// Once is an object that will perform exactly one action.type Once struct &#123; // done indicates whether the action has been performed. // It is first in the struct because it is used in the hot path. // The hot path is inlined at every call site. // Placing done first allows more compact instructions on some architectures (amd64/x86), // and fewer instructions (to calculate offset) on other architectures. done uint32 m Mutex&#125; 123456789101112131415func (o *Once) Do(f func()) &#123; if atomic.LoadUint32(&amp;o.done) == 0 &#123; // Outlined slow-path to allow inlining of the fast-path. o.doSlow(f) &#125;&#125;func (o *Once) doSlow(f func()) &#123; o.m.Lock() defer o.m.Unlock() if o.done == 0 &#123; defer atomic.StoreUint32(&amp;o.done, 1) f() &#125;&#125; 可以从这段代码看到它使用了atomic包，这是golang提供的原子操作相关的包。 关于原子操作，在操作系统这门课的教科书上市这样描述的： 一个操作中所有的动作要么全做，要么全部做。换言之，它是一个不可分割的基本单位。原子操作在系统态下执行，常驻内存。 简而言之，原子操作是不可中断的。所以在这里，无论是读(load)或者写(store)操作，同时只能存在一种操作，要么读,要么写。","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.nekilc.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://www.nekilc.com/tags/Golang/"}]},{"title":"Vue引用类型的监听watch","slug":"Vue/Vue引用类型的监听watch","date":"2020-08-15T17:01:06.469Z","updated":"2020-08-16T19:57:24.898Z","comments":true,"path":"XH9XQ6.html","link":"","permalink":"http://www.nekilc.com/XH9XQ6.html","excerpt":"和Vue watch之间的小故事。","text":"和Vue watch之间的小故事。 在今天的项目编写中，遇到了vue监听起作用，但无法知道具体哪个值变化的问题，在搜索了一会后，几乎千篇一律的让我加deep监听属性，但是都忽略一个问题，他们确实解决了监听的问题，其实在打印新旧值的时候你会发现，两个值是一样的并无新旧值区别，原因是因为引用传递，所以监听到的是引用的地址。在那个时间点，那个引用地址存的就是你修改后的值,也就是说监听回调的新旧值参数对象是同一个地址同一个引用。 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;el-button @click=\"change(4)\"&gt;&lt;/el-button&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import Vue from 'vue'export default Vue.extend(&#123; data() &#123; return &#123; obj:&#123; a: 0, b: 1 &#125; &#125; &#125;, watch:&#123; obj: &#123; deep: true, handler: function (val,oldVal) &#123; console.log(val) console.log(oldVal) &#125; &#125; &#125;, methods: &#123; change(v: number) &#123; this.obj.a=v &#125; &#125;&#125;)&lt;/script&gt; 当你通过其他事件将obj.a赋予新值时，譬如4，那么控制台输出的会是： 那么解决这个问题的方法就是使用computed去获取单个属性，然后监听这个computed的值： 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;el-button @click=\"change(4)\"&gt;&lt;/el-button&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import Vue from 'vue'export default Vue.extend(&#123; data() &#123; return &#123; obj:&#123; a: 0, b: 1 &#125; &#125; &#125;, computed:&#123; a: function(): number&#123; return this.obj.a &#125; &#125;, watch:&#123; a: &#123; handler: function (val,oldVal) &#123; console.log(val) console.log(oldVal) &#125; &#125; &#125;, methods: &#123; change(v: number) &#123; this.obj.a=v &#125; &#125;&#125;)&lt;/script&gt; 结果如下了。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.nekilc.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.nekilc.com/tags/Vue/"}]},{"title":"Element-UI中Table高度自适应问题","slug":"Vue/Element-UI中Table高度自适应问题","date":"2020-08-12T22:40:24.883Z","updated":"2020-08-12T23:07:16.936Z","comments":true,"path":"3XDPK46.html","link":"","permalink":"http://www.nekilc.com/3XDPK46.html","excerpt":"","text":"我今天在写代码时，发现了这个问题，无论我怎么调整父级容器，包括绝对定位、Flex布局等，发现El-table这个组件的高度不受父级约束，为了解决这个问题，我尝试了获取浏览器可见区域高度，将El-table的max-height属性绑定到 Vue 数据上，设置定时器去改变这个数据，即可保证初始高度正确以及后续浏览器窗口变化导致的高度变化。 代码如下： 123456789mounted () &#123; // eslint-disable-next-line @typescript-eslint/no-this-alias const that = this console.log(this.$refs.bodyheader) setInterval(function () &#123; // 这一串数据是我减去了table组件上方固定高度的组件的高度。 that.tableHeight = document.documentElement.clientHeight - 50 - 62 - 41 - 16 - 32 - 50 - 30 &#125;, 500)&#125;, 效果如图：","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.nekilc.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.nekilc.com/tags/Vue/"}]},{"title":"Kotlin安卓开发-环境搭建（一）","slug":"安卓/Kotlin安卓开发-环境搭建（一）","date":"2020-02-29T15:29:46.000Z","updated":"2020-09-16T10:30:35.484Z","comments":true,"path":"1X1JYEX.html","link":"","permalink":"http://www.nekilc.com/1X1JYEX.html","excerpt":"","text":"前言 本文旨在小白也能够顺利安装安卓开发环境，解决虚拟设备、SDK、GRADLE的路径修改问题。 Java开发环境 该教程无需手动安装Java环境。 集成开发环境（Android Studio） . 下载安装JetBrain的ToolBox 点击下载 . 修改ToolBox的安装地址 打开ToolBox的设置 选择你想存储该应用程序的路径并应用 返回工具列表，找到AS 可以选择你想要的版本，个人喜欢最新版 . 配置SDK路径 等待安装完成，打开AS 提示不能增加AndroidSDK，原因是因为需要设置代理，没有代理的话直接取消，会打开配置界面 关掉如下配置界面，会回到启动界面 打开设置 找到如下界面，点击edit编辑按钮 选择你需要安装的位置后，一路next，然后等待很长一段时间，我使用了代理，所以非常快。 结束之后你会看到如下界面，此时路径已经修改，说明你成功了 . 配置安卓虚拟设备 进行如下操作，以进行下一步，勾选HAXM ，然后应用（apply） 应用后会出现一个界面，一路next，建议该界面下选择2gb 关闭AS，进行环境变量配置 打开window设置，界面搜索 编辑系统环境变量 选择环境变量 新建一个名为 ANDROID_SDK_HOME的环境变量，变量值填写你自己的路径,然后确定 以及 应用 再次启动AS，启动界面，选择如下设置去设置安卓虚拟设备 选择一个设备，当然你也可以自定义设备信息（屏幕尺寸、颜色深度等等）， 下一步之后，会看到这个界面，下载一个安卓系统镜像 左下角提示没有选择系统镜像，你需要点击相应安卓版本的下载（Download）按钮下载 点击下载后会弹出如下界面 等待完成即可 完成之后，下载按钮消失了，点击选择它，然后下一步就完成了 . 配置GRADLE路径 调试 . 虚拟设备调试 . 真实设备调试","categories":[{"name":"安卓","slug":"安卓","permalink":"http://www.nekilc.com/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.nekilc.com/tags/Java/"},{"name":"Android","slug":"Android","permalink":"http://www.nekilc.com/tags/Android/"}]},{"title":"数据完整性设计理解","slug":"数据库/数据完整性设计理解","date":"2020-02-05T19:06:37.000Z","updated":"2020-07-21T10:54:50.482Z","comments":true,"path":"YE6KFM.html","link":"","permalink":"http://www.nekilc.com/YE6KFM.html","excerpt":"数据库完整性是指数据库中数据的正确性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据庠完整性约束的设计。数据库完整性约束可以通过DBMS^DBMS或应用程序来实现，基于DBMS的完整性约束作为模式的一部分存入数据库中。通过DBMS实现的数据库完整性按照数据库设计步骤进行设计，而由应用软件实现的数据库完整性则纳入应用软件设计。","text":"数据库完整性是指数据库中数据的正确性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据庠完整性约束的设计。数据库完整性约束可以通过DBMS^DBMS或应用程序来实现，基于DBMS的完整性约束作为模式的一部分存入数据库中。通过DBMS实现的数据库完整性按照数据库设计步骤进行设计，而由应用软件实现的数据库完整性则纳入应用软件设计。 1. 数据库完整性设计原则 静态约束应尽量包含在数据库模式中，而动态约束由应用程序实现。 触发器性能开销大，非用不可时使用before触发器。 制定完整性约束的命名规范。 根据业务规则对数据库完整性进行测试，排除约束冲突。 2. 数据库完整性的作用 防止合法用户使用数据库时向数据库中添加不合语义的数据。 降低应用程序的复杂性，提高应用程序的运行效率。 比应用程序更容易实现数据库的完整性。 3. 六类数据库完整性约束 列级静态约束 元组级静态约束 关系级静态约束 列级动态约束 元组级动态约束 关系级动态约束 4. 数据库完整性设计示例 需求分析阶段 经过系统分析员、数据库分析员和用户的共同努力，确定系统模型中应该包含的对象，如人事及工资管理系统中的部门、员工和经理等，以及各种业务规则。 在完成寻找业务规则的工作之后，确定要作为数据库完整性的业务规则，并对业务规则进行分类。其中作为数据库模式一部分的完整性设计按下面的过程进行，而由应用软件来实现的数据库完整性设计将按照软件工程的方法进行。 概念结构设计阶段 概念结构设计阶段是将依据需求分析的结果转换成一个独立于具体DBMS的概念模型，即实体关系图（Entity-RelationshipDiagram,ERD）。在概念结构设计阶段就要开始数据库完整性设计的实质阶段，因为此阶段的实体关系将在逻辑结构设计阶段转化为实体完整性约束和参照完整性约束，到逻辑结构设计阶段将完成设计的主要工作。 逻辑结构设计阶段 此阶段就是将概念结构转换为某个DBMS所支持的数据模型，并对其进行优化，包括对关系模型的规范化。此时，依据DBMS提供的完整性约束机制，对尚未加入逻辑结构中的完整性约束列表，逐条选择合适的方式加以实现。 在逻辑结构设计阶段结束时，作为数据库模式一部分的完整性设计也就基本完成了。每种业务规则都可能有好几种实现方式，应该选择对数据库性能影响最小的一种，有时需通过实际测试来决定。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.nekilc.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.nekilc.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}],"categories":[{"name":"运维","slug":"运维","permalink":"http://www.nekilc.com/categories/%E8%BF%90%E7%BB%B4/"},{"name":"杂文","slug":"杂文","permalink":"http://www.nekilc.com/categories/%E6%9D%82%E6%96%87/"},{"name":"Golang","slug":"Golang","permalink":"http://www.nekilc.com/categories/Golang/"},{"name":"Vue","slug":"Vue","permalink":"http://www.nekilc.com/categories/Vue/"},{"name":"安卓","slug":"安卓","permalink":"http://www.nekilc.com/categories/%E5%AE%89%E5%8D%93/"},{"name":"数据库","slug":"数据库","permalink":"http://www.nekilc.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.nekilc.com/tags/Vue/"},{"name":"Java","slug":"Java","permalink":"http://www.nekilc.com/tags/Java/"},{"name":"Golang","slug":"Golang","permalink":"http://www.nekilc.com/tags/Golang/"},{"name":"数据库","slug":"数据库","permalink":"http://www.nekilc.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Android","slug":"Android","permalink":"http://www.nekilc.com/tags/Android/"}]}