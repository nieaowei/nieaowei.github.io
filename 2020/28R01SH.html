<!DOCTYPE html><html><head><head><meta charset="utf-8"/><meta http-equiv="pragma" content="no-cache"/><meta http-equiv="cache-control" content="no-cache"/><meta http-equiv="expires" content="0"/><title>记录许久未碰的Makefile文件编写|Nekilc</title><meta name="author" content="Nekilc"/><meta name="description" content="Makefile是软件构建工具make的构建文件，说白了其实和shell脚本非常类似，但是它更加便捷，用来处理复杂的文件依赖关系，常用于交叉编译。可以使用它来步骤化编译源码，构建程序或库文件。"/><meta name="description" content="1. 简言离上次使用Makefile还是半年前了，曾经用的很熟练的我，现在用起来已经很生疏了，最近在实训又一次接触到它，便写下这篇文章以实例记录Makefile文件的编写，为了下次不在踩坑。
2. 一个简单的例子项目目录如下：

Makefile文件如下：
12main:main.c	gcc -o "/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/><meta property="og:title" content="记录许久未碰的Makefile文件编写"/><meta property="og:site_name" content="Nekilc"/><meta property="og:image"/><link rel="icon" href="/favicon.png"/><link rel="stylesheet" href="/css/bootstrap.min.css"/><link rel="stylesheet" href="/css/font-awesome.css"/><link rel="stylesheet" href="/css/style.css"/><link rel="stylesheet" href="/css/responsive.css"/><link rel="stylesheet" href="/css/highlight.css"/><link rel="stylesheet" href="/css/google-fonts.css"/><script src="/js/jquery-2.0.3.min.js"></script><meta name="generator" content="Hexo 4.2.0"></head></head><body><nav class="navbar navbar-inverse navbar-fixed-top" id="main-nav" role="navigation"><div class="container"><button class="navbar-header navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/">Nekilc</a><div class="collapse navbar-collapse nav-menu"><ul class="nav navbar-nav"><li> <a href="/archives" title="All the articles."><i></i>Archives</a></li><li> <a href="/categories" title="All the categories."><i></i>Categories</a></li><li> <a href="/tags" title="All the tags."><i></i>Tags</a></li><li> <a href="/about" title="About me."><i></i>About</a></li></ul></div></div></nav><div class="clearfix"></div><div class="container"><div class="content"><div class="page-header"><h1>记录许久未碰的Makefile文件编写</h1></div><div class="row post"><div class="col-md-9"><div id="top_meta"></div><div class="mypage"><div class="alert alert-success description"><i class="fa fa-info-circle"></i>Makefile是软件构建工具make的构建文件，说白了其实和shell脚本非常类似，但是它更加便捷，用来处理复杂的文件依赖关系，常用于交叉编译。可以使用它来步骤化编译源码，构建程序或库文件。</div><h1 id="1-简言"><a href="#1-简言" class="headerlink" title="1. 简言"></a>1. 简言</h1><p>离上次使用Makefile还是半年前了，曾经用的很熟练的我，现在用起来已经很生疏了，最近在实训又一次接触到它，便写下这篇文章以实例记录Makefile文件的编写，为了下次不在踩坑。</p>
<h1 id="2-一个简单的例子"><a href="#2-一个简单的例子" class="headerlink" title="2. 一个简单的例子"></a>2. 一个简单的例子</h1><p>项目目录如下：</p>
<p><img src="https://gitee.com/nieaowei/images/raw/master/blog/20200616033820.png" alt></p>
<p>Makefile文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main:main.c</span></span><br><span class="line">	gcc -o main main.c</span><br></pre></td></tr></table></figure>

<p>在终端执行<code>make main</code>就可以构建程序了</p>
<p><img src="https://gitee.com/nieaowei/images/raw/master/blog/20200616034739.png" alt></p>
<p><code>main</code>其实就是我们的构建目标（target），最终我们可以编译出名为<code>main</code>的可执行程序，<code>gcc -o main main.c</code>其实就和终端下或者说shell脚本里面一样，是个执行命令。<br>然而makefile仅仅如此吗？那我还不如去用shell脚本。看下面这个例子，他的便利之处便体现出来了。</p>
<h1 id="3-一个便捷体现的例子"><a href="#3-一个便捷体现的例子" class="headerlink" title="3. 一个便捷体现的例子"></a>3. 一个便捷体现的例子</h1><p>项目目录如下：</p>
<p><img src="https://gitee.com/nieaowei/images/raw/master/blog/20200616034853.png" alt></p>
<p>Makefile文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SRC		:= main.c sum.c</span><br><span class="line"></span><br><span class="line"><span class="section">run:main</span></span><br><span class="line">	./main</span><br><span class="line"></span><br><span class="line"><span class="section">main:<span class="variable">$(SRC)</span></span></span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>

<p>这次我们又多了一个文件。我在<code>main.c</code>文件里面调用了<code>sum.c</code>的一个函数，这次是多文件编译，而且又多了一个构建目标<code>run</code>。执行看下结果：</p>
<p><img src="https://gitee.com/nieaowei/images/raw/master/blog/20200616035346.png" alt></p>
<p>可以很清晰的看到它按顺序去执行几个指令，<code>gcc</code>编译指令和<code>./main</code>程序执行。</p>
<p>那么逻辑就很清楚了，当我构建<code>run</code>目标时，它会先行构建<code>main</code>目标，因为<code>main</code>是<code>run</code>的依赖。以此类推，那么<code>SRC</code>中的文件就是<code>main</code>构建的依赖了。</p>
<p>在这份文件中，还有两个关键点 <code>$@</code> 和<code>$^</code> ,前者是表示本次构建的目标也就是<code>main</code>,后者则代表本次构建的依赖<code>SRC</code>中的所有文件。对于这里，还有一个关键词<code>$&lt;</code>，它代表的是依赖中的第一个文件，也就是这里的<code>main.c</code>文件,如果将此处的 <code>$^</code> 替换为 <code>$&lt;</code> 那么完整的构建语句是<code>gcc -o main main.c</code>,但它是无法编译的，因为它调用了另外文件的函数。</p>
<p>问题又来了，我每写一个文件，难道就要来写一下makefile吗？当然不是。Make还有更加便利的方式，它拥有一系列的处理函数和强大的类型推断功能，下面就以一个完整的项目来分析。</p>
<h1 id="3-完整项目结构的例子"><a href="#3-完整项目结构的例子" class="headerlink" title="3. 完整项目结构的例子"></a>3. 完整项目结构的例子</h1><p>项目目录如下：</p>
<p><img src="https://gitee.com/nieaowei/images/raw/master/blog/20200616040556.png" alt></p>
<p>在这里，<code>bin</code>为构建的可执行程序目录，<code>include</code>是自写头文件和<code>lib</code>头文件的存放文件夹，<code>lib</code>是调用库的存放文件夹，<code>obj</code>是交叉编译的中间文件的存放文件夹，<code>src</code>是c语言资源文件的存放文件夹。</p>
<p>makefile文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">CC		:= gcc</span><br><span class="line">CFLAGS	:= -Wall -Wextra -g</span><br><span class="line"></span><br><span class="line">BIN		:= bin</span><br><span class="line">SRC		:= src</span><br><span class="line">INCLUDE	:= <span class="keyword">include</span></span><br><span class="line">LIB		:= lib</span><br><span class="line">OBJ 	:= obj</span><br><span class="line"></span><br><span class="line">LIBRARIES	:=</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(OS)</span>,Windows_NT)</span><br><span class="line">EXECUTABLE	:= main.exe</span><br><span class="line">SOURCEDIRS	:= <span class="variable">$(SRC)</span></span><br><span class="line">INCLUDEDIRS	:= <span class="variable">$(INCLUDE)</span></span><br><span class="line">LIBDIRS		:= <span class="variable">$(LIB)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">EXECUTABLE	:= main</span><br><span class="line">SOURCEDIRS	:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC)</span> -type d)</span></span><br><span class="line">INCLUDEDIRS	:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(INCLUDE)</span> -type d)</span></span><br><span class="line">LIBDIRS		:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(LIB)</span> -type d)</span></span><br><span class="line">OBJDIRS		:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(OBJ)</span> -type d)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">CINCLUDES	:= <span class="variable">$(<span class="built_in">patsubst</span> %,-I%, $(INCLUDEDIRS:%/=%)</span>)</span><br><span class="line">CLIBS		:= <span class="variable">$(<span class="built_in">patsubst</span> %,-L%, $(LIBDIRS:%/=%)</span>)</span><br><span class="line"></span><br><span class="line">SOURCES		:= <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">patsubst</span> %,%/*.c, <span class="variable">$(SOURCEDIRS)</span>)</span>)</span><br><span class="line">OBJECTS		:= <span class="variable">$(<span class="built_in">patsubst</span> %.c,<span class="variable">$(OBJ)</span>/%.o, $(<span class="built_in">notdir</span> <span class="variable">$(SOURCES)</span>)</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">all:  <span class="variable">$(BIN)</span>/<span class="variable">$(EXECUTABLE)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-<span class="variable">$(RM)</span> <span class="variable">$(BIN)</span>/<span class="variable">$(EXECUTABLE)</span></span><br><span class="line">	-<span class="variable">$(RM)</span> <span class="variable">$(OBJECTS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">run: all</span></span><br><span class="line">	./<span class="variable">$(BIN)</span>/<span class="variable">$(EXECUTABLE)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BIN)</span>/<span class="variable">$(EXECUTABLE)</span>: <span class="variable">$(OBJECTS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CINCLUDES)</span> <span class="variable">$(CLIBS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(LIBRARIES)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJECTS)</span>:<span class="variable">$(OBJDIRS)</span>/%.o:<span class="variable">$(SOURCEDIRS)</span>/%.c</span><br><span class="line">	- <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CINCLUDES)</span> <span class="variable">$(CLIBS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(LIBRARIES)</span></span><br></pre></td></tr></table></figure>

<p>可以看到在文件开头定义了很多变量，而变量的值都是环境变量中可执行程序(这里指<code>gcc</code>编译器)和目录，在这里提几个关键的点：</p>
<ul>
<li><code>$(shell xxxx)</code> 这是调用<code>shell</code>去执行后续的xxx命令，在此处就是调用了find在当前目录查找文件夹。</li>
<li><code>$(patsubst xx,ss,dir)</code> 这个是make提供的字符串处理函数，是将dir文件中xx替换成ss，对于此处<code>CINCLUDES</code>变量来说，是将<code>INCLUDEDIRS</code>文件夹下面的文件全部替换了 <code>-I文件</code>，<code>%</code>百分号是个通匹配符。举个例子，xx为<code>%.c</code>,ss为<code>%.o</code>,如果dir目录下有main.c和sum.c两个文件，那么该函数输出的是 main.o 和sum.o。</li>
<li><code>$(notdir xxx)</code>是将xxx中的文件的路径去掉，比如说<code>src/main.c</code> 和 <code>src/sum.c</code>,调用这个函数后的输出结果为 <code>main.c</code>和<code>sum.c</code>。</li>
<li><code>$(wildcard xxx)</code> 是去xxx中查找匹配的文件。举个例子xxx为<code>%.c</code>就会去查找目录下所有<code>.c</code>文件，可以解决在某些情况下，% 通配符失效的问题。</li>
<li><code>.PHONY target</code> 这个关键字就是声明这个target是个伪目标，是个不会产生实际文件的目标。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(OBJECTS)</span>:<span class="variable">$(OBJDIRS)</span>/%.o:<span class="variable">$(SOURCEDIRS)</span>/%.c</span><br><span class="line">	- <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CINCLUDES)</span> <span class="variable">$(CLIBS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(LIBRARIES)</span></span><br></pre></td></tr></table></figure>
<p>这段代码是典型的静态模式规则，使用gcc将指定目录下所有的.c文件编译成了.o文件，这里<code>%</code>的作用就非常大了，也体现了make的自动推导功能，而且会循环构建目标。<br>前后两个百分号的值通过自动推导回事一样的，<code>$(OBJECTS)</code>是构建目标的集合，<code>$(OBJDIRS)/%.o</code>指明了本次构建模板的模式，而<code>$(SOURCEDIRS)/%.c</code>就是构建依赖了，那么他的自动推导是怎么一回事呢？</p>
<p>举个例子，如果构建模目标集合中有 <code>obj/main.o obj/sum.o</code>，那么当目标 <code>%.o</code> 为 <code>main.o</code> 时，后面的 <code>%.c</code> 就会自动推导出 <code>main.c</code>,从而这次执行的命令就为<code>gcc -c -o main.o main.c</code>，第一个目标构建完后，就会去构建集合中的第二个目标，直到所有目标构建完成。</p>
<p>还有一个关键的点就是<code>$(INCLUDEDIRS:%/=%)</code>,这个操作是将该目录下所有的文件都取出来。比如该目录为<code>src</code>,目标有两个文件<code>main.c</code>和<code>sum.c</code>,那么这里输出将是<code>src/main.c</code>和<code>src/sum.c</code>。</p>
<p>我们还可以通过上面这点通过make的隐藏的规则来生成目标文件，缺点就是不能指定文件夹和不能指定<code>include</code>目录。你只能通过shell命令去移动。举个例子，<code>$(SOURCES:.c=.o)</code>,对于这里，会将<code>SOURCES</code>中的.c文件编译成.o文件，得益于隐式规则，他会自动使用gcc去编译，但如果.c文件中引用了其他路径下的include头文件，那么编译将会报错。这就是为什么我在上面使用了这段代码：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(OBJECTS)</span>:<span class="variable">$(OBJDIRS)</span>/%.o:<span class="variable">$(SOURCEDIRS)</span>/%.c</span><br><span class="line">	- <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CINCLUDES)</span> <span class="variable">$(CLIBS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(LIBRARIES)</span></span><br></pre></td></tr></table></figure>

<p>因为我的头文件都在放在了<code>include</code>文件夹下，如果不这么做，那么依靠上述隐式编译是无法通过的。</p>
<p>最后看看结果：</p>
<p><img src="https://gitee.com/nieaowei/images/raw/master/blog/20200616050700.png" alt></p>
<p>看到了三条编译命令，分别生成了<code>main.o</code>、<code>sum.o</code>和<code>main</code>可执行程序。最后执行了<code>run</code>目标，执行了程序，并输出了程序结果。</p>
<p>可以看到obj文件夹下生成了.o文件,以及bin目录下的可执行程序:</p>
<p><img src="https://gitee.com/nieaowei/images/raw/master/blog/20200616051703.png" alt></p>
<h1 id="4-补充一点GCC知识"><a href="#4-补充一点GCC知识" class="headerlink" title="4. 补充一点GCC知识"></a>4. 补充一点GCC知识</h1><ul>
<li>-I 指明头文件文件夹。</li>
<li>-L 指明库文件文件夹。</li>
<li>-Wall 打开警告。</li>
<li>-g 生成调试信息。</li>
<li>-Wextra 产生额外的警告,其实就是更严格的代码检测模式。</li>
</ul>
<h1 id="5-源代码"><a href="#5-源代码" class="headerlink" title="5. 源代码"></a>5. 源代码</h1><p><a href="https://github.com/nieaowei/study/tree/master/linux/makefile-demo" target="_blank" rel="noopener">https://github.com/nieaowei/study/tree/master/linux/makefile-demo</a></p>
</div><div><center><div class="pagination"><a class="btn btn-default disabled" type="button"><i class="fa fa-arrow-circle-o-left"></i>上一页</a><a class="btn btn-default" href="/" type="button"><i class="fa fa-home"></i>Home</a><a class="btn btn-default" href="/2020/2NK8Q7N.html" type="button"><i class="fa fa-arrow-circle-o-right"></i>下一页</a></div></center></div></div><div class="col-md-3" id="post_meta"><div class="meta-widget"><i class="fa fa-clock-o"></i> 2020-06-16 03:18:08<br/><i class="fa fa-pencil"></i> 2020-06-16 05:27:10</div><div class="meta-widget"><a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a><ul class="tag_box list-unstyled collapse in" id="categorys"><li><a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式<span>1</span></a></li></ul></div><div class="meta-widget"><a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a><ul class="tag_box list-unstyled collapse in" id="tags"><li><a href="/tags/Linux/">Linux<span>3</span></a></li><li><a href="/tags/Makefile/">Makefile<span>1</span></a></li><li><a href="/tags/Make/">Make<span>1</span></a></li><li><a href="/tags/C/">C<span>1</span></a></li></ul></div><div class="meta-widget"><a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a><ul class="toc collapse in" id="toc"><span class="toc-title">Contents</span><ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#1-简言"><span class="toc-article-text">1. 简言</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#2-一个简单的例子"><span class="toc-article-text">2. 一个简单的例子</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#3-一个便捷体现的例子"><span class="toc-article-text">3. 一个便捷体现的例子</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#3-完整项目结构的例子"><span class="toc-article-text">3. 完整项目结构的例子</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#4-补充一点GCC知识"><span class="toc-article-text">4. 补充一点GCC知识</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#5-源代码"><span class="toc-article-text">5. 源代码</span></a></li></ol></ul></div><div class="widget"><h4>最近更新</h4><ul class="entry list-unstyled"><li><a href="/2020/28R01SH.html" title="Makefile是软件构建工具make的构建文件，说白了其实和shell脚本非常类似，但是它更加便捷，用来处理复杂的文件依赖关系，常用于交叉编译。可以使用它来步骤化编译源码，构建程序或库文件。"><i class="fa fa-file-o"></i>记录许久未碰的Makefile文件编写</a></li><li><a href="/2020/138BRG9.html" title="依然坚持减少xml的使用，使用JetPack组件化编程，本次将探究Fragment的生命周期，以及实现Navigation进行Fragment间的跳转。"><i class="fa fa-file-o"></i>JetPack Compose 安卓开发-Fragme...</a></li><li><a href="/2020/22X88J.html" title="使用现在最流行的容器化技术来管理Mysql数据库或者其他开发环境。"><i class="fa fa-file-o"></i>Docker部署Mysql数据库</a></li><li><a href="/2020/8BV7RJ.html" title="网络代理是API网关开发中非常重要的一环，也常用于负载均衡方面，本文记录API网关开发中网络代理的一些基础知识。"><i class="fa fa-file-o"></i>Go语言详解网络代理</a></li><li><a href="/2020/2NK8Q7N.html" title="通知是指 Android 在应用界面之外显示的消息，旨在向用户提供提醒、来自他人的通信信息或应用中的其他及时信息。用户可以点按通知来打开应用，或直接从通知中执行操作。"><i class="fa fa-file-o"></i>JetPack Compose 安卓开发-普通通知示例</a></li></ul></div></div></div></div></div><div class="container-narrow"><div class="container-narrow"><footer><p>&copy; 2020 <a href="https://www.nekilc.com" target="_blank">Nekilc</a></p></footer></div></div></body></html>